package serializers

import (
	"encoding/json"
	"strings"
	"testing"

	"github.com/spdx/tools-golang/spdx"
	"github.com/spdx/tools-golang/spdx/v2/common"
	"github.com/spdx/tools-golang/spdx/v2/v2_3"
	"github.com/stretchr/testify/require"

	protospdx "github.com/protobom/protobom/pkg/formats/spdx"
	"github.com/protobom/protobom/pkg/mod"
	"github.com/protobom/protobom/pkg/native"
	"github.com/protobom/protobom/pkg/sbom"
)

func TestExtRefCategoryFromProtobomExtRef(t *testing.T) {
	s23 := NewSPDX23()
	for extRefType, name := range sbom.ExternalReference_ExternalReferenceType_name {
		t.Run(name, func(t *testing.T) {
			res := s23.extRefCategoryFromProtobomExtRef(&sbom.ExternalReference{
				Type: sbom.ExternalReference_ExternalReferenceType(extRefType),
			})

			switch sbom.ExternalReference_ExternalReferenceType(extRefType) {
			case sbom.ExternalReference_BOWER, sbom.ExternalReference_MAVEN_CENTRAL,
				sbom.ExternalReference_NPM, sbom.ExternalReference_NUGET:
				require.Equal(t, spdx.CategoryPackageManager, res)
			case sbom.ExternalReference_SECURITY_ADVISORY, sbom.ExternalReference_SECURITY_FIX,
				sbom.ExternalReference_SECURITY_OTHER:
				require.Equal(t, spdx.CategorySecurity, res)
			default:
				require.Equal(t, spdxOther, res)
			}
		})
	}
}

func TestExtRefTypeFromProtobomExtRef(t *testing.T) {
	s23 := NewSPDX23()
	for extRefType, name := range sbom.ExternalReference_ExternalReferenceType_name {
		t.Run(name, func(t *testing.T) {
			extRefType := extRefType
			res := s23.extRefTypeFromProtobomExtRef(&sbom.ExternalReference{
				Type: sbom.ExternalReference_ExternalReferenceType(extRefType),
			})

			switch sbom.ExternalReference_ExternalReferenceType(extRefType) {
			case sbom.ExternalReference_BOWER:
				require.Equal(t, spdx.PackageManagerBower, res)
			case sbom.ExternalReference_MAVEN_CENTRAL:
				require.Equal(t, spdx.PackageManagerMavenCentral, res)
			case sbom.ExternalReference_NPM:
				require.Equal(t, spdx.PackageManagerNpm, res)
			case sbom.ExternalReference_NUGET:
				require.Equal(t, spdx.PackageManagerNuGet, res)
			case sbom.ExternalReference_OTHER:
				require.Equal(t, spdxOther, res)
			case sbom.ExternalReference_SECURITY_ADVISORY:
				require.Equal(t, spdx.SecurityAdvisory, res)
			case sbom.ExternalReference_SECURITY_FIX:
				require.Equal(t, spdx.SecurityFix, res)
			case sbom.ExternalReference_SECURITY_OTHER:
				require.Equal(t, spdx.SecurityUrl, res)
			default:
				require.Equal(t, spdxOther, res)
			}
		})
	}
}

func TestSpdxNamespaceFromProtobomID(t *testing.T) {
	for _, tc := range []struct {
		name     string
		sut      string
		expected string
		options  SPDX23Options
		mustErr  bool
	}{
		{
			name:     "plain-uri-no-fragment",
			sut:      "https://spdx.org/spdxdocs/28b3c8c8-687c-4df5-9744-ee8e7d644392",
			expected: "https://spdx.org/spdxdocs/28b3c8c8-687c-4df5-9744-ee8e7d644392",
			options:  DefaultSPDX23Options,
			mustErr:  false,
		},
		{
			name:     "plain-uri-valid-fragment",
			sut:      "https://spdx.org/spdxdocs/48ddaa40-309a-40f7-8a8a-643a2262b144#SPDXRef-DOCUMENT",
			expected: "https://spdx.org/spdxdocs/48ddaa40-309a-40f7-8a8a-643a2262b144",
			options:  DefaultSPDX23Options,
			mustErr:  false,
		},
		{
			// Deprecated: This tests uses the deprecated FailOnInvalidDocIdFragment setting
			name:     "plain-uri-valid-fragment-fail",
			sut:      "https://spdx.org/spdxdocs/48ddaa40-309a-40f7-8a8a-643a2262b144#OtherRef",
			expected: "urn", // Expect an autogenerated URN
			options:  SPDX23Options{FailOnInvalidDocIdFragment: true},
			mustErr:  false,
		},
		{
			// Deprecated: This tests uses the deprecated FailOnInvalidDocIdFragment setting
			name:     "plain-uri-valid-fragment-nofail",
			sut:      "https://spdx.org/spdxdocs/48ddaa40-309a-40f7-8a8a-643a2262b144#OtherRef",
			expected: "urn", // Expect an autogenerated URN
			options:  SPDX23Options{FailOnInvalidDocIdFragment: false},
			mustErr:  false,
		},
		{
			name:     "urn",
			sut:      "urn:uuid:3e671687-395b-41f5-a30f-a58921a69b79",
			expected: "urn:uuid:3e671687-395b-41f5-a30f-a58921a69b79",
			options:  DefaultSPDX23Options,
			mustErr:  false,
		},
		{
			name:     "random-string",
			sut:      "yolo",
			expected: "urn", // Expect an autogenerated URN
			options:  DefaultSPDX23Options,
			mustErr:  false,
		},
		{
			name:     "package-url",
			sut:      "pkg:npm/%40angular/animation@12.3.1",
			expected: "pkg:npm/%40angular/animation@12.3.1",
			options:  DefaultSPDX23Options,
			mustErr:  false,
		},
		{
			name:    "blank-url-fail",
			sut:     "",
			options: SPDX23Options{GenerateDocumentID: false},
			mustErr: true,
		},
		{
			name:     "blank-url",
			sut:      "",
			expected: "*", // Just make sure it's not empty
			options:  DefaultSPDX23Options,
			mustErr:  false,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			r, err := spdxNamespaceFromProtobomID(tc.options, tc.sut)
			if tc.mustErr {
				require.Error(t, err)
				return
			}
			require.NoError(t, err)

			switch tc.expected {
			case "*":
				require.NotEmpty(t, r)
			case "urn":
				require.True(t, strings.HasPrefix(r, "urn:uuid"))
			default:
				require.Equal(t, tc.expected, r)
			}
		})
	}
}

func TestPropertiesMod(t *testing.T) {
	propertyData := []struct {
		name string
		data string
	}{
		{"test A", "this is data A"},
		{"test B", "this is the second value"},
	}
	doc := sbom.NewDocument()
	n := sbom.NewNode()
	n.Id = "24cc905f-da4a-401d-8f0e-4b1b29246259"

	// Add properties to the node
	for _, pd := range propertyData {
		p := sbom.NewProperty()
		p.Name = pd.name
		p.Data = pd.data
		n.Properties = append(n.Properties, p)
	}

	doc.NodeList.AddRootNode(n)
	s := NewSPDX23()
	for _, tc := range []struct {
		name                string
		serializeopts       *native.SerializeOptions
		spdxopts            SPDX23Options
		annotationsExpected bool
		mustErr             bool
	}{
		{
			name: "no-annotations",
			serializeopts: &native.SerializeOptions{
				Mods: map[mod.Mod]struct{}{},
			},
			annotationsExpected: false,
		},
		{
			name: "annotations",
			serializeopts: &native.SerializeOptions{
				Mods: map[mod.Mod]struct{}{
					mod.SPDX_RENDER_PROPERTIES_IN_ANNOTATIONS: {},
				},
			},
			annotationsExpected: true,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			packages, err := s.buildPackages(
				tc.serializeopts, SPDX23Options{}, doc,
			)
			if tc.mustErr {
				require.Error(t, err)
				return
			}
			require.Len(t, packages, 1)
			if !tc.annotationsExpected {
				require.Empty(t, packages[0].Annotations)
				return
			}
			require.Len(t, packages[0].Annotations, 2)
			for i, a := range packages[0].Annotations {
				protoProp := sbom.NewProperty()
				require.NoError(t, json.Unmarshal([]byte(a.AnnotationComment), protoProp))
				require.Equal(t, propertyData[i].name, protoProp.Name)
				require.Equal(t, propertyData[i].data, protoProp.Data)
				require.Equal(t, common.ElementID(n.Id), packages[0].Annotations[i].AnnotationSPDXIdentifier.ElementRefID)
				// We always set the date to unixtime 0 to make the annotation reproducible
				require.Equal(t, "1970-01-01T00:00:00Z", packages[0].Annotations[i].AnnotationDate)
				require.Equal(t, "Tool", packages[0].Annotations[i].Annotator.AnnotatorType)
				require.Equal(t, "protobom - v1.0.0", packages[0].Annotations[i].Annotator.Annotator)
				require.Equal(t, "OTHER", packages[0].Annotations[i].AnnotationType)
			}
		})
	}
}

func TestBuildPackages(t *testing.T) {
	s23 := NewSPDX23()

	for _, tc := range []struct {
		name     string
		doc      *sbom.Document
		spdxopts SPDX23Options
		validate func(t *testing.T, packages []*spdx.Package, err error)
	}{
		{
			name: "multiple-licenses-fail",
			doc: func() *sbom.Document {
				doc := sbom.NewDocument()
				n := sbom.NewNode()
				n.Id = "test-node-id-1"
				n.Licenses = []string{"MIT", "Apache-2.0"}
				doc.NodeList.Nodes = append(doc.NodeList.Nodes, n)
				return doc
			}(),
			spdxopts: SPDX23Options{
				FailOnMultipleLicenses: true,
			},
			validate: func(t *testing.T, packages []*spdx.Package, err error) {
				require.Error(t, err)
				require.Contains(t, err.Error(), "has multiple licenses")
			},
		},
		{
			name: "license-expression-with-OR",
			doc: func() *sbom.Document {
				doc := sbom.NewDocument()
				n := sbom.NewNode()
				n.Id = "test-node-id-2"
				n.Licenses = []string{"MIT", "Apache-2.0"}
				doc.NodeList.Nodes = append(doc.NodeList.Nodes, n)
				return doc
			}(),
			spdxopts: SPDX23Options{
				FailOnMultipleLicenses:    false,
				LicenseExpressionOperator: "OR",
			},
			validate: func(t *testing.T, packages []*spdx.Package, err error) {
				require.NoError(t, err)
				require.Len(t, packages, 1)
				require.Equal(t, "MIT OR Apache-2.0", packages[0].PackageLicenseDeclared)
			},
		},
		{
			name: "license-expression-with-AND",
			doc: func() *sbom.Document {
				doc := sbom.NewDocument()
				n := sbom.NewNode()
				n.Id = "test-node-id-3"
				n.Licenses = []string{"MIT", "Apache-2.0"}
				doc.NodeList.Nodes = append(doc.NodeList.Nodes, n)
				return doc
			}(),
			spdxopts: SPDX23Options{
				FailOnMultipleLicenses:    false,
				LicenseExpressionOperator: "AND",
			},
			validate: func(t *testing.T, packages []*spdx.Package, err error) {
				require.NoError(t, err)
				require.Len(t, packages, 1)
				require.Equal(t, "MIT AND Apache-2.0", packages[0].PackageLicenseDeclared)
			},
		},
		{
			name: "supplier-and-originator",
			doc: func() *sbom.Document {
				doc := sbom.NewDocument()

				n := sbom.NewNode()
				n.Id = "node-with-supplier-and-originator"

				supplier := &sbom.Person{
					Name:  "ACME Corp",
					IsOrg: true,
				}
				n.Suppliers = append(n.Suppliers, supplier)

				originator := &sbom.Person{
					Name:  "John Doe",
					Email: "john@example.com",
					IsOrg: false,
				}
				n.Originators = append(n.Originators, originator)

				doc.NodeList.Nodes = append(doc.NodeList.Nodes, n)
				return doc
			}(),
			spdxopts: SPDX23Options{},
			validate: func(t *testing.T, packages []*spdx.Package, err error) {
				require.NoError(t, err)
				require.Len(t, packages, 1)

				require.NotNil(t, packages[0].PackageSupplier)
				require.Equal(t, "Organization", packages[0].PackageSupplier.SupplierType)

				require.NotNil(t, packages[0].PackageOriginator)
				require.Equal(t, "Person", packages[0].PackageOriginator.OriginatorType)
				require.Contains(t, packages[0].PackageOriginator.Originator, "John Doe")
				require.Contains(t, packages[0].PackageOriginator.Originator, "john@example.com")
			},
		},
		{
			name: "primary-purpose-mapping",
			doc: func() *sbom.Document {
				doc := sbom.NewDocument()

				appNode := sbom.NewNode()
				appNode.Id = "app-node"
				appNode.PrimaryPurpose = []sbom.Purpose{sbom.Purpose_APPLICATION}
				doc.NodeList.Nodes = append(doc.NodeList.Nodes, appNode)

				libNode := sbom.NewNode()
				libNode.Id = "lib-node"
				libNode.PrimaryPurpose = []sbom.Purpose{sbom.Purpose_LIBRARY}
				doc.NodeList.Nodes = append(doc.NodeList.Nodes, libNode)

				return doc
			}(),
			spdxopts: SPDX23Options{},
			validate: func(t *testing.T, packages []*spdx.Package, err error) {
				require.NoError(t, err)
				require.Len(t, packages, 2)

				for _, pkg := range packages {
					switch string(pkg.PackageSPDXIdentifier) {
					case "app-node":
						require.Equal(t, "APPLICATION", pkg.PrimaryPackagePurpose)
					case "lib-node":
						require.Equal(t, "LIBRARY", pkg.PrimaryPackagePurpose)
					}
				}
			},
		},
		{
			name: "checksums-mapping",
			doc: func() *sbom.Document {
				doc := sbom.NewDocument()

				n := sbom.NewNode()
				n.Id = "node-with-checksums"
				n.Hashes = map[int32]string{
					int32(sbom.HashAlgorithm_SHA1):   "a94a8fe5ccb19ba61c4c0873d391e987982fbbd3",
					int32(sbom.HashAlgorithm_SHA256): "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
				}

				doc.NodeList.Nodes = append(doc.NodeList.Nodes, n)
				return doc
			}(),
			spdxopts: SPDX23Options{},
			validate: func(t *testing.T, packages []*spdx.Package, err error) {
				require.NoError(t, err)
				require.Len(t, packages, 1)

				checksums := packages[0].PackageChecksums
				require.Len(t, checksums, 2)

				checksumMap := make(map[string]string)
				for _, cs := range checksums {
					checksumMap[string(cs.Algorithm)] = cs.Value
				}

				require.Equal(t, "a94a8fe5ccb19ba61c4c0873d391e987982fbbd3", checksumMap["SHA1"])
				require.Equal(t, "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08", checksumMap["SHA256"])
			},
		},
		{
			name: "external-references",
			doc: func() *sbom.Document {
				doc := sbom.NewDocument()

				n := sbom.NewNode()
				n.Id = "node-with-external-refs"

				n.ExternalReferences = append(n.ExternalReferences, &sbom.ExternalReference{
					Type:    sbom.ExternalReference_NPM,
					Url:     "https://www.npmjs.com/package/example",
					Comment: "NPM reference",
				}, &sbom.ExternalReference{
					Type:    sbom.ExternalReference_SECURITY_ADVISORY,
					Url:     "https://nvd.nist.gov/vuln/detail/CVE-2021-1234",
					Comment: "Security advisory",
				})

				doc.NodeList.Nodes = append(doc.NodeList.Nodes, n)
				return doc
			}(),
			spdxopts: SPDX23Options{},
			validate: func(t *testing.T, packages []*spdx.Package, err error) {
				require.NoError(t, err)
				require.Len(t, packages, 1)

				refs := packages[0].PackageExternalReferences
				require.Len(t, refs, 2)

				var npmRef, securityRef *v2_3.PackageExternalReference
				for _, ref := range refs {
					switch ref.RefType {
					case spdx.PackageManagerNpm:
						npmRef = ref
					case spdx.SecurityAdvisory:
						securityRef = ref
					}
				}

				require.NotNil(t, npmRef)
				require.Equal(t, spdx.CategoryPackageManager, npmRef.Category)
				require.Equal(t, "https://www.npmjs.com/package/example", npmRef.Locator)

				require.NotNil(t, securityRef)
				require.Equal(t, spdx.CategorySecurity, securityRef.Category)
				require.Equal(t, "https://nvd.nist.gov/vuln/detail/CVE-2021-1234", securityRef.Locator)
			},
		},
		{
			name: "empty-download-location",
			doc: func() *sbom.Document {
				doc := sbom.NewDocument()

				n := sbom.NewNode()
				n.Id = "node-empty-download"
				n.UrlDownload = ""

				doc.NodeList.Nodes = append(doc.NodeList.Nodes, n)
				return doc
			}(),
			spdxopts: SPDX23Options{},
			validate: func(t *testing.T, packages []*spdx.Package, err error) {
				require.NoError(t, err)
				require.Len(t, packages, 1)
				require.Equal(t, protospdx.NOASSERTION, packages[0].PackageDownloadLocation)
			},
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			packages, err := s23.buildPackages(&native.SerializeOptions{}, tc.spdxopts, tc.doc)
			tc.validate(t, packages, err)
		})
	}
}
